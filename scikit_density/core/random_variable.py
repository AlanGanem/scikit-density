# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_core.random_variable.ipynb (unless otherwise specified).

__all__ = ['RandomVariable', 'RVArray']

# Cell
from functools import partial

import scipy.stats as stats
import numpy as np
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.preprocessing import QuantileTransformer

import KDEpy as kdepy

from ..utils import cos_sim_query, sample_multi_dim, ctqdm

# Cell

class RandomVariable():
    '''
    A container for distribution objects
    '''

    @classmethod
    def from_weights(cls, values, weights, n_samples = 100, **ecdf_kwargs):
        data = np.random.choice(values,size = n_samples, p = weights)
        return cls.__init__(data, **ecdf_kwargs)

    def __init__(self, data, verbose = False, **ecdf_kwargs):
        self.samples = data
        self.n_dim = 1 if len(data.shape) == 1 else data.shape[-1]
        self._fitted_dists = {}
        self.log_likelihood = []
        self.verbose = False
        self.ecdf = QuantileTransformer(**ecdf_kwargs).fit(data)
        return

    def __getitem__(self, item):
        if item == 'best':
            try:
                item = self._best_fit_alias
            except AttributeError:
                raise AttributeError('RandomVariable object has no "best" fit yet. Fit at least one density function through fit_dist method')

        return self._fitted_dists[item][0]

    #def __repr__(self):
    #    return f'RandomVariable({str(self.samples)})'

    def fit_best(self, candidates = ['norm','halfnorm','lognorm']):
        #fit all and make alias for best fit
        self._fit_all(self.samples, candidates)
        return self


    def fit_dist(self, dist, **dist_kwargs):
        return self._fit_dist(self.samples,dist, **dist_kwargs)

    def _check_best(self):
        dists_aliases = list(self._fitted_dists)
        dists_arr = np.array([i[1] for i in self._fitted_dists.values()])
        best_fit_idx = np.argmax(dists_arr)
        self._best_fit_alias = dists_aliases[best_fit_idx]
        return

    def _fit_all(self, data, candidates):
        #TODO: check for multiplicity in candidates aliases
        for candidate in ctqdm(candidates, verbose = self.verbose):
            self.fit_dist(candidate)
        return self

    def _fit_dist(self, data, dist, **dist_kwargs):
        '''
        fits a specified distribution through scipy.stats.rv_continuous.fit method
        '''
        alias, dist_name = self._handle_dist_names(dist)
        alias, dist_class = self._get_dist_from_name(alias, dist_name)
        if alias.lower() == 'best':
            raise ValueError('"best" cannot be an alias for a distribution. its internally assgined to the best fit dist')
        if alias != 'kde':
            if self.n_dim > 1:
                raise ValueError('rv_continuous distributions is only available for 1d distributions. Use "kde" dist instead'.)
            params = dist_class.fit(data)
            log_likelihood = np.log(np.product(dist_class.pdf(data,*params)))
            self._fitted_dists = {**self._fitted_dists, **{alias:(dist_class(*params),log_likelihood)}}
            self.log_likelihood = list({**dict(self.log_likelihood), **{alias:log_likelihood}}.items())
        else:
            dist = dist_class(**dist_kwargs).fit(data)
            log_likelihood = np.log(np.product(dist.pdf(data)))
            self._fitted_dists = {**self._fitted_dists, **{alias:(dist,log_likelihood)}}
            self.log_likelihood = list({**dict(self.log_likelihood), **{alias:log_likelihood}}.items())

        #update 'best' alias
        self._check_best()
        return self


    def _get_dist_from_name(self, alias, dist_name):
        '''
        handles dist_names. if str tries to get an attribute from scipy.stats accordingly
        that is also instance of scipy.stats.rv_continuous
        '''
        if isinstance(dist_name,str):
            if isinstance(getattr(stats,dist_name), stats.rv_continuous):
                alias = dist_name
                return (alias, getattr(stats,dist_name))
            elif dist_name.lower() == 'kde':
                alias = 'kde'
                return (alias, KDE)
            else:
                raise ValueError(f'dist must be a valid scipy.stats.rv_continuous instance, not {getattr(stats,dist_name)}')

        elif isinstance(dist_name, stats.rv_continuous):
            return (alias, dist_name)
        else:
            raise ValueError(f'dist must be a valid scipy.stats.rv_continuous instance or str, not {dist_name}')

    def _handle_dist_names(self, candidate_value):
        '''
        checks the inputs in elements of "candidates"
        returns a named tuple
        '''
        if isinstance(candidate_value, str):
            return candidate_value, candidate_value

        elif isinstance(candidate_value, tuple):

            if not len(candidate_value) == 2:
                raise ValueError(f'candidate named tuple must be of size 2, "{candidate_value}" has size {len(candidate_value)}')

            if not isinstance(candidate_value[0], str):
                raise ValueError(f'a candidate must be a str or named tuple (alias[str],<rv_continuous intance>), alias is of type {candidate_value[0].__class__}')

            else:
                return candidate_value

    def sample(self, size, dist = 'empirical', **kwargs):
        if dist == 'empirical':
            sampled_idxs = np.random.choice([*range(self.samples.shape[0])], size = size, **kwargs)
            return self.samples[sampled_idxs]
        else:
            return self[dist].rvs(size = size, **kwargs)

    def cdf(self, data, dist = 'empirical'):
        if dist == 'empirical':
            return self.ecdf.transform(data)
        else:
            return self[dist].cdf(data)

    def pdf(self, data, dist = 'best'):
        if dist == 'empirical':
            raise ValueError('empirical quantile distribution has no pdf definition')
        else:
            return self[dist].pdf(data)

    def ppf(self, data, dist = 'empirical'):
        if dist == 'empirical':
            return self.ecdf.inverse_transform(data)
        else:
            return self[dist].ppf(data)

    def entropy(self, data, dist = ''):
        pass


# Cell

class RVArray():
    '''
    An array that contains RandomVariable objects and facilitates method calls and getting attributes
    '''
    def __init__(self, data):
        ''' the constructor recieves a list of RandomVariable items'''
        self.data = np.array(data)

    def __getattr__(self, attr):
        attr_list = [getattr(i,attr) for i in self.data]
        return RVArray(attr_list)

    def __call__(self, *args, **kwargs):
        results = [i(*args,**kwargs) for i in self.data]
        if all([isinstance(i,np.ndarray) for i in results]):
            return np.array(results)
        else:
            return RVArray(results)

    def __getitem__(self, *args):

        if len(args) > 1:
            return RVArray(self.data[args])
        else:
            if args[0].__class__ == str:
                return RVArray([i[args[0]] for i in self.data])
            else:
                return self.data[args]

    def __repr__(self):
        return f'RVArray({str(self.data)})'